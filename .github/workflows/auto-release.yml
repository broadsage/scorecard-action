name: Automated Release

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [closed]

permissions:
  contents: write
  packages: write
  id-token: write
  attestations: write

jobs:
  analyze-and-release:
    name: Auto Release Analysis
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push') ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    outputs:
      should-release: ${{ steps.analyze.outputs.should-release }}
      version-bump: ${{ steps.analyze.outputs.version-bump }}
      new-version: ${{ steps.analyze.outputs.new-version }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze Commits for Release
        id: analyze
        run: |
          # Get latest tag
          latest_tag=$(git tag -l "v*.*.*" | sort -V | tail -n1 || echo "v0.0.0")
          echo "Latest tag: $latest_tag"
          
          # Parse current version
          if [[ "$latest_tag" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            major=${BASH_REMATCH[1]}
            minor=${BASH_REMATCH[2]}
            patch=${BASH_REMATCH[3]}
          else
            major=0; minor=0; patch=0
          fi
          
          echo "Current version: $major.$minor.$patch"
          
          # Analyze commits since last tag
          if [[ "$latest_tag" == "v0.0.0" ]]; then
            commits_since_tag=$(git log --oneline --format="%s" HEAD)
          else
            commits_since_tag=$(git log --oneline --format="%s" "${latest_tag}..HEAD")
          fi
          
          # Determine version bump based on conventional commits
          should_release="false"
          version_bump="patch"
          
          while IFS= read -r commit_msg; do
            echo "Analyzing: $commit_msg"
            
            # Skip merge commits and bot commits
            if [[ "$commit_msg" =~ ^Merge|^chore\(deps\)|dependabot|github-actions ]]; then
              continue
            fi
            
            # Check for breaking changes (major bump)
            if [[ "$commit_msg" =~ feat!:|fix!:|BREAKING|^[a-z]+!: ]]; then
              version_bump="major"
              should_release="true"
              echo "üö® Breaking change detected: $commit_msg"
            # Check for features (minor bump)
            elif [[ "$commit_msg" =~ ^feat:|^feature: ]]; then
              if [[ "$version_bump" != "major" ]]; then
                version_bump="minor"
              fi
              should_release="true"
              echo "‚ú® Feature detected: $commit_msg"
            # Check for fixes (patch bump)
            elif [[ "$commit_msg" =~ ^fix:|^bugfix: ]]; then
              should_release="true"
              echo "üêõ Fix detected: $commit_msg"
            # Check for other release-worthy changes
            elif [[ "$commit_msg" =~ ^perf:|^security: ]]; then
              should_release="true"
              echo "‚ö° Performance/Security change: $commit_msg"
            fi
          done <<< "$commits_since_tag"
          
          # Calculate new version
          case $version_bump in
            "major") new_major=$((major + 1)); new_minor=0; new_patch=0 ;;
            "minor") new_major=$major; new_minor=$((minor + 1)); new_patch=0 ;;
            "patch") new_major=$major; new_minor=$minor; new_patch=$((patch + 1)) ;;
          esac
          
          new_version="v${new_major}.${new_minor}.${new_patch}"
          
          echo "Analysis Results:"
          echo "- Should Release: $should_release"
          echo "- Version Bump: $version_bump"
          echo "- New Version: $new_version"
          
          # Set outputs
          echo "should-release=$should_release" >> $GITHUB_OUTPUT
          echo "version-bump=$version_bump" >> $GITHUB_OUTPUT
          echo "new-version=$new_version" >> $GITHUB_OUTPUT

  create-release:
    name: Create Automated Release
    needs: analyze-and-release
    if: needs.analyze-and-release.outputs.should-release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create Tag and Release
        run: |
          VERSION="${{ needs.analyze-and-release.outputs.new-version }}"
          BUMP_TYPE="${{ needs.analyze-and-release.outputs.version-bump }}"
          
          echo "üè∑Ô∏è Creating tag and release: $VERSION (${BUMP_TYPE} release)"
          
          # Create tag with detailed message
          git tag -a "$VERSION" -m "Automated $BUMP_TYPE release $VERSION

          Generated from conventional commits analysis.
          Bump type: $BUMP_TYPE
          
          This release was created automatically by GitHub Actions."
          
          # Push tag
          git push origin "$VERSION"
          
          echo "‚úÖ Tag $VERSION created and pushed!"

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@e435ccd777264be153ace6237001ef4d979d3a7a # v6.1.0
        with:
          distribution: goreleaser
          version: '~> v2'
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COSIGN_EXPERIMENTAL: 1

      - name: Update Major Version Tag
        run: |
          VERSION="${{ needs.analyze-and-release.outputs.new-version }}"
          
          # Extract major version (e.g., v1.2.3 -> v1)
          if [[ $VERSION =~ ^v([0-9]+)\. ]]; then
            MAJOR_VERSION="v${BASH_REMATCH[1]}"
            echo "üîÑ Updating major version tag: $MAJOR_VERSION -> $VERSION"
            
            # Create or update major version tag
            git tag -f "$MAJOR_VERSION" "$VERSION"
            git push --force origin "$MAJOR_VERSION"
            
            echo "‚úÖ Major version tag $MAJOR_VERSION updated to point to $VERSION"
          else
            echo "‚ö†Ô∏è Could not parse major version from $VERSION"
          fi

      - name: Generate Job Summary
        if: always()
        run: |
          VERSION="${{ needs.analyze-and-release.outputs.new-version }}"
          BUMP_TYPE="${{ needs.analyze-and-release.outputs.version-bump }}"
          
          echo "## üöÄ Automated Release Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** $BUMP_TYPE release" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** Conventional commits analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "**Status:** ‚úÖ Success" >> $GITHUB_STEP_SUMMARY
            echo "**Release URL:** https://github.com/${{ github.repository }}/releases/tag/$VERSION" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Usage" >> $GITHUB_STEP_SUMMARY
            echo "Update your workflows to use the new version:" >> $GITHUB_STEP_SUMMARY
            echo '```yaml' >> $GITHUB_STEP_SUMMARY
            echo "uses: ${{ github.repository }}@$VERSION" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** ‚ùå Failed" >> $GITHUB_STEP_SUMMARY
          fi